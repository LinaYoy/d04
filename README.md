# Работа с файлами

## Аннотация

Эти задания позволят тебе изучить, как работать с файлами с расширениями .txt, .json и .csv.

# Chapter I
## Работа с файлами вручную
> При работе с любым файлом, самое главное два действия:
> 1. Открыть файл перед работой с ним.
> 2. Закрыть файл после работы с ним.
> 
> Если не закрыть файл, то все изменения не будут выполнены, а открытый файл будет занимать память компьютера.
> Есть два метода работы с этими действиями. Первый метод - ручной.
> 
> Ты вручную открываешь файл с помощью метода **open** и записываешь это в переменную
> 
> `file = open('folde/text.txt', 'r', encoding='utf-8')`
> 
> Первый аргумент `'folder/text.txt'` - это путь к файлу, который нужно открыть. Путь может быть относительным (относительно текущей рабочей папки) и абсолютным, то есть начинаться с корневой папки в системе.
> Когда будешь делать задания у тебя могут возникать ошибки, которые говорят, что файла по такому пути нет, особенно, если путь указан относительным.
> 
> Второй аргумент `'r'` - это режим открытия файла, данный режим открывает файл на чтение. Есть режимы на запись, дозапись и т.д.
> Их ты можешь легко загуглить.
> 
> Третий аргумент `encoding='utf-8'` - это кодировка. Что это такое можешь прочитать в интернете, самый распространенный - это **utf-8**.
> Если при чтении или записи вместо нормальных символов, ты видишь крокозябры или какие-то непонятные сочетания символов и цифр, то это проблема с кодировкой.
> 
> После чтения с аргументом `file` ты уже начинаешь осуществлять операции. Когда все операции завершены надо закрыть файл.
> с помощью метода **close**.
> 
> `file.close()`
___
## Контекстный менеджер
> А теперь поговорим о втором методе - работа с контекстным менеджером **with**. Если файл был открыт через блок **with**, то
> он автоматически будет закрыт, когда код внутри **with** будет выполнен.
> 
> ```python
> with open('folde/text.txt', 'r', encoding='utf-8') as file:
>   something_code...
> ```
> 
> Советую сразу приучаться работать с файлами через блок **with**. На самом деле **with** работает не только с файлами,
> но это уже сложные и продвинутые темы.
> 
> Подводя итог можно сказать, что любая работа с файлами содержит часть с открытием и закрытием файла.
> В случае файлов с форматом *.txt* больше ничего не требуется. Для других форматов, например, *.csv* или *.json* есть соответствующие библиотеки.

### Структура папок и файлов

> Данные о пациентах будут храниться в единой папке. Я подготовил пример такой папки.
> Папка называется *patients/* и находится в *materials/*.
> 
> Внутри содержаться папки, имена которых соответствуют ФИО пациентов. Заметьте,
> что все они выглядят единым образом - *Имя_Фамилия_Отчество*. 
> 
> Внутри каждой из папок содержаться файл *card.json*. Этот формат используется для хранения карточек пациентов. 
> 
> Помимо файла *card.json* в папках пациентов присутствует папка *visits*, в которой находятся текстовые файлы. Каждый из файлов содержит записи с одного приема.
> Название файла всегда выглядит, как дата в формате *год-месяц-день* (*2024-03-10.txt*).
> 
> Помимо папки *materials/patients* внутри папки *materials* лежит файл *schedule.csv*, в котором записана электронная очередь в специальном формате *.csv*.
> К слову, данный формат может открываться с помощью экселей и других подобных программ.
> 
> Перед тем как работать с этими папками и файлами, **СКОПИРУЙТЕ** их в свою папку *src/*.
> А в программах указывайте пути к папкам и файлам, которые лежат в *src/*. 


## Chapter II

### txt файлы

> Файлы с расширением *.txt* - это обыкновенные текстовые файлы, которые обычно открываются с помощью какого-нибудь блокнота.
> Простой, как три копейки, данный формат используется просто для каких-то текстовых записей, часто не форматированных.
> 
> С точки зрения кода данный формат не требует для использования каких-то внешних библиотек. Есть много полезных методов для работы 
> с текстовыми файлами, записанными в переменную - `read(), readline(), write()` и много других. Одни читают весь файл, другие читают построчно и 
> их можно прогонять в цикле, другие считывают строки и записывают их отдельно в элементы списка. Перед работой с ними, постарайся найти нужный тебе
> в данный момент времени.

### Задание 1

Отлично, можно приступить к заданиям. 

> В первом задании необходимо научиться читать текстовые файлы. А именно при вводе фамилии, имени и отчества пациента,
> дату старого приема,  выводить содержимое на экран. Если же файла нет, необходимо об этом уведомлять.
> При этом ФИО пусть будет не восприимчиво к регистру, т.е. реализовать возможность ввода - Иванов Иван Иванович, иванов иван иванович, Иванов иван Иванович и т.д.
> И кстати, если не правильно вводить ФИО, то пусть программа также уведомляет об отсутствии такого пациента!

Перед выполнением заданий необходимо скопировать папку *materials/patients* и файл *materials/schedule.csv* в папку *src/*.

Получается необходимо реализовать следующий функционал:
1. Пользователь вводит в клавиатуры:
   - фамилию, имя и отчество - `Иванов Иван Иванович`;
   - дату интересующего приема - `2024-09-03` (если пациент существует).
2. При вводе с клавиатуры пользователь должен видеть следующие надписи (порядок обязателен):
   - `Введите ФИО полностью через пробел (Иванов Иван Иванович): `;
   - `Введите дату приема, который хотите посмотреть: ` (если пациент существует).
3. Пользователь может вводить ФИО в любом регистре, при этом введенное ФИО должно приводиться к виду, которым называются папки с пациентами.
4. Необходимо проверить существует ли папка с таким пациентом, если НЕТ, то нужно выводить фразу `Такого пациента нет!` и **завершить программу**.
5. С помощью введенных данных нужно сформировать путь до нужно файла и прочитать содержимое.
6. Содержимое файла вывести на экран.
7. Если файл не был найден, то выводить на экран фразу - `Такого приема не было!`.

Нужно подумать, как проверить наличие папки с пациентом. Для этого необходимо использовать модуль *os*. Тебе надо разобраться с методами и функциями этого модуля.

P.S. Надо не забыть, что для подстановки каких-то частей пути в полный путь до файла или папки отлично подойдут **f строки**.

### Задание 2

> После этого я хочу, чтобы ты реализовал следующее: после ввода ФИО (регистронезависмость оставляем), пусть программа показывается список предыдущих приемов.
> Если же приемов не было, то пусть пишет, что это первый прием и программа прекращает работу. Если же приемы есть, то дальше
> пусть делает тоже самое, что и в 1 задании.

Получается, что:
1. Пользователь вводит в клавиатуры:
   - фамилию, имя и отчество - `Иванов Иван Иванович`;
   - дату интересующего приема - `2024-09-03` (если пациент существует).
2. При вводе с клавиатуры пользователь должен видеть следующие надписи (порядок обязателен):
   - `Введите ФИО полностью через пробел (Иванов Иван Иванович): `;
   - `Введите дату приема, который хотите посмотреть: ` (если пациент существует).
3. Пользователь может вводить ФИО в любом регистре, при этом введенное ФИО должно приводиться к виду, которым называются папки с пациентами.
4. Необходимо проверить существует ли папка с таким пациентом, если НЕТ, то нужно выводить фразу `Такого пациента нет!` и **завершить программу**.
5. После ввода ФИО (например, `Иванов Иван Иванович`) необходимо выводить на экран:
   
   **ЕСЛИ** в папке *visits* есть хоть один файл, то: 
   - ```
     Предыдущие приемы:
     2024-09-03
     2024-09-06
     2024-09-10

   **ИНАЧЕ**:
   - `Это первый прием!`, **после этого программа завершает работу**.
6. Если программа не завершила работу, повторить пункты 5-7 из **Задания №1**.

А как же посмотреть сколько и какие файлы в папке *visits*? Надо попробовать поискать в том же модуле *os*.

### Задание 3

> Последним в этом блоке, необходимо реализовать возможность ввода записей текущего приема. Пусть пользователь также будет вводить ФИО пациента (регистронезависмость оставляем),
> после этого пусть он имеет возможность вводить любые записи и, при вводе двух пустых строк, записи бы фиксировались в файле.
> При этом один Enter пусть работает, как обычный перенос строки, два Enter подряд - это два переноса, то есть добавление пустой строки.
> И сделай, пожалуйста такой же формат файла, как и в других приемах.

Что ж, выходит:
1. Пользователь вводит с клавиатуры:
    - фамилию, имя и отчество - `Иванов Иван Иванович`;
    - любые записи, которые он хочет сохранить в файл.
2. При вводе с клавиатуры пользователь должен видеть следующие надписи (порядок обязателен):
   - `Введите ФИО полностью через пробел (Иванов Иван Иванович): `;
   - `Введите записи (чтобы закончить введите два раза пустую строку): ` (при этом надпись должна выводиться перед многострочным вводом один раз, можно вывести с помощью **print** перед инпутами).
3. Пользователь может вводить ФИО в любом регистре, при этом введенное ФИО должно приводиться к виду, которым называются папки с пациентами.
4. Необходимо проверить существует ли папка с таким пациентом, если НЕТ, то нужно выводить фразу `Такого пациента нет!` и **завершить программу**.
5. Пользователь должен осуществлять многострочный ввод, с возможностью переноса строки и пропуска одной строки.
При этом, если он пропустил 2 строку, то ввод должен прекращаться. Пример (слева проставлена нумерация строк, она не вводится, нужна чтобы отследить пустые строки):
```
1 Введите записи (чтобы закончить нажмите два раза Enter):
2 Ввожу данные
3 
4 Такие данные
5 
6 Сякие данные
7
8
```
6. Все записи должны быть записаны в файл.
7. Файл должен называться, как текущая дата. Допустим сегодня - 2024-09-01. Тогда записи записываются в файл *visits/2024-09-01.txt*.
8. Текущую дату необходимо определять в момент выполнения программы, а не фиксировать в коде.
9. Внутри записанного файла после последних символьных записей должна быть одна пустая строка (**не больше!**). Можно посмотреть, примеры файлов со всеми остальными приемами.
Пример (слева проставлена нумерация строк, нужна чтобы отследить пустые строки):
```
1 Ввожу данные
2 
3 Такие данные
4 
5 Сякие данные
6
```

Определить текущую дату на момент выполнения программы поможет модуль *datetime*.

## Chapter III

### json файлы

> Файлы с расширением *.json* - это специальный формат файлов, который изначально пришел с другого языка программирования,
> а именно с JavaScript. Файлы json  - это структурированные файлы, и самое приятное, что в Python есть тип данных, который
> очень похож на формат json файлов - это словари. Json файлы устроены почти также, как и словари (хотя возможно это словари устроены почти также, как json). Тоже ключи, тоже значения.
> Отличия в том, какие типы данных могут быть записаны в *.json* в качестве ключей и значений.
> 
> С точки зрения кода данный формат уже требует библиотеки для комфортной работы с такими файлами. Библиотека так и называется - **json**.
> Принцип работы с *.json* файлами следующий - вы открываете файл, как обычно с помощью **with**, и записывайте его в какую-нибудь переменную **file** (смотри общие принципы работы с файлами), 
> а дальше внутри блока **with** с помощью библиотеки вызываете методы, которые отвечают за чтение и запись файла. 
> 
> Обязательно разберись, в какой питоновский формат будет прочитан *.json* файл с помощью библиотеки **json**. И из какого формата удобнее всего записывать данные в *.json* файл.

### Задание 4

> В этом блоке нужно поработать с карточками пациента. Повторюсь, что они лежат в папках пациентов, файл - *card.json*.
> В первом задании блока, необходимо, чтобы при указании фамилии, имени и отчества пациента, выводилась его карточка. 
> При этом ФИО пусть будет не восприимчиво к регистру, т.е.
> Как и в заданиях из первого блока, предусмотри что, если не правильно ввести ФИО, то пусть программа уведомляет об отсутствии такого пациента!
> Также нужно проверять есть ли карточка в папке и если ее нет, то предупреждать об этом.

И того:
1. Пользователь вводит в клавиатуры:
   - фамилию, имя и отчество - `Иванов Иван Иванович`.
2. При вводе с клавиатуры пользователь должен видеть следующую надпись - `Введите ФИО полностью через пробел (Иванов Иван Иванович): `
3. Пользователь может вводить ФИО в любом регистре, при этом введенное ФИО должно приводиться к виду, которым называются папки с пациентами.
4. Необходимо проверить существует ли папка с таким пациентом, если НЕТ, то нужно выводить фразу `Такого пациента нет!` и **завершить программу**.
5. Если папка существует, то необходимо выводить на экран содержимое файла *card.json*, который лежит в папке этого пациента.
6. Если файла *card.json* не существует, то необходимо вывести на экран фразу - `Карточки пациента нет!` и **завершить программу**.
7. Вывод существующей карточки на экран должен быть таким же, как данные записаны в файле. При этом отступы от начала строк до ключей должны составлять 4 пробела. Пример вывода в терминале:
```
{
    "Фамилия": "Иванов",
    "Имя": "Иван",
    "Отчество": "Иванович",
    "Дата рождения": "1994-11-23",
    "Пол": "М"
}
```
### Задание 5

> После того, как ты научился читать карточки пациентов, давай сделаем возможность создавать карточку для тех пациентов, у которых ее нет.
> То есть нужно проверять есть ли карточка в папке и если ее нет, то предупреждать об этом и давать возможность по порядку ввести все поля в карточке.
> После этого было бы неплохо ее также вывести на экран. При вводе данных для карточки - фамилии, имени, отчества и пола нужно, также обрабатывать любой регистр.
> При этом в файл данные должны записываться в тех регистрах, в каких они записаны в других карточках.

Получается, что:
1. Пользователь вводит в клавиатуры:
   - фамилию, имя и отчество - `Иванов Иван Иванович`;\
    Если такой пациент есть, но его карточка отсутствует:
   - фамилию - `Иванов`;
   - имя - `Иван`;
   - отчество - `Иванович`;
   - дата рождения - `1993-03-20`;
   - пол - `М`.
2. При вводе с клавиатуры пользователь должен видеть следующие надписи (порядок обязателен):
   - `Введите ФИО полностью через пробел (Иванов Иван Иванович): `;\
   Если такой пациент есть, но его карточка отсутствует:
   - `Введите фамилию пациента: `;
   - `Введите имя пациента: `;
   - `Введите отчество пациента: `;
   - `Введите дату рождения пациента (1994-01-10): `;
   - `Введите пол пациента пациента (М или Ж): `.
3. Пользователь может вводить ФИО в любом регистре, при этом введенное ФИО должно приводиться к виду, которым называются папки с пациентами.
4. Необходимо проверить существует ли папка с таким пациентом, если НЕТ, то нужно выводить фразу `Такого пациента нет!` и **завершить программу**.
5. Если папка существует, то необходимо выводить на экран содержимое файла *card.json*, который лежит в папке этого пациента.
6. Если файла *card.json* не существует, то необходимо вывести на экран фразу - `Карточки пациента нет!`.
7. После вывода этой фразы нужно сразу дать пользователю ввести нужные данные для карточки (см. пункт 1 и 2).
8. Введенные для карточки данные надо преобразовать в тот регистр, который принят для этих данных во всех карточках (см. карточки других пациентов).
9. Сформированную карточку необходимо записать в файл *card.json* в папку пациента в том формате, как и карточки других пациентов.
10. После этого необходимо вывести на экран сформированную карточку, как в пункте 5.

## Chapter IV

### csv файлы

> Файлы с расширением *.csv* - это тестовые файлы, предназначенные для записи табличных данных. С csv файлами умеют работать, как Excel, так и другие подобные программы.
> Это очень популярный формат файлов. Каждая строка в файле - это строка таблицы. Первая строка - это обычно строка с заголовками колонок.
> Колонки между собой разделяются с помощью **разделителей** (прости за тавтологию). По-умолчанию используется запятая. Однако, в качестве разделителя 
> можно использовать и другие символы, главное, чтобы они не встречались внутри значений в полях таблицы.
> То есть, если в качестве разделителя выбрана запятая, но одна из колонок содержит текст с запятыми внутри него, то при чтение такого файла сто процентов будет неверным.
> В данном случае лучше использовать другой разделитель, например `|`.
> 
> С точки зрения кода данный формат (как и json) требует библиотеки для комфортной работы с такими файлами. Библиотека так и называется - **сsv**.
> Принцип работы с *.csv* файлами следующий - вы открываете файл, как обычно с помощью **with**, и записывайте его в какую-нибудь переменную **file** (смотри общие принципы работы с файлами), 
> а дальше внутри блока **with** с помощью библиотеки вызываете методы, которые отвечают за чтение и запись файла.
> 
> Важное отличие при работе с csv файлами заключается в том, что внутри функции **open** нужно еще использовать аргумент **newline**.
> Не забудь про него, когда будет обрабатывать такие файлы!

### Задание 6

> В данном блоке необходимо работать с электронной очередью, которая записана в файле *schedule.csv* (который вы надеюсь скопировали в папку *src/* из папки *materials/*).
> Для начала нужно просто выводить эту электронную очередь на экран в красивом виде. 

План выполнения задания:
1. Прочитать файл *schedule.csv*.
2. Содержимое файла вывести с помощью библиотеки **tabulate**, используя формат ***github***.
3. Пример вывода:
```
| Время   | Пациент                     | Принят(-а) врачом   |
|---------|-----------------------------|---------------------|
| 08:00   | Иванов Иван Иванович        | Нет                 |
| 08:30   | Петров Петр Петрович        | Нет                 |
| 09:00   | Сидорова Светлана Сергеевна | Нет                 |
| 09:30   | Воробьева Елена Петровна    | Нет                 |
```

### Задание 7

> Для второго задания этого блока у меня есть следующая задумка. В электронной очереди есть колонка `Принят(-а) врачом`.
> По-умолчанию у всех пациентов стоит значение `Нет`. Хотелось бы, чтобы после приема в электронной очереди это значение бы
> менялось на `Да`. Давай начнем с того, чтобы пользователь вводил ФИО пациента (регистронезависимое само собой), после этого в электронной
> очереди должно меняться значение у этого пациента с `Нет` на `Да`, то есть файл *schedule.csv* должен быть обновлен.
> 
> Если же пациента нет в очереди, то пусть программа предупреждает об этом и завершается.

Для реализации этого задания нужно учесть следующие пункты:
1. Пользователь вводит в клавиатуры:
   - фамилию, имя и отчество - `Иванов Иван Иванович`.
2. При вводе с клавиатуры пользователь должен видеть следующую надпись - `Введите ФИО полностью через пробел (Иванов Иван Иванович): `
3. Пользователь может вводить ФИО в любом регистре, при этом введенное ФИО должно приводиться к виду, которым записываются ФИО в очереди.
4. Необходимо прочитать файл *schedule.csv*.
5. После необходимо проверить есть ли данный пациент в очереди, если НЕТ, то нужно выводить фразу `Такого пациента нет!` и **завершить программу**.
6. Если пациент есть, то нужно в его строке очереди в колонке `Принят(-а) врачом` заменить значение `Нет` на `Да`.
7. Далее очередь должна записаться в тот же файл *schedule.csv* в том же виде, как и до этого, просто с одним измененным значением..
8. В конце очередь с измененным значением должна выводиться на экран в том же виде, как и в **Задании №6** (см. пункты 2-3).

## Chapter V

### Задание 8

После выполнения трех блоков, ты можешь немного передохнуть. Только немного. Теперь тебе необходимо собрать все три блока вместе. Теперь просмотр электронной очереди необходимо просматривать отдельно, а вот все остальные наработки в том или ином виде входят в итоговую программу.

План итоговой программы:
1. При запуске программы запрашивать ФИО - `Введите ФИО полностью через пробел (Иванов Иван Иванович): `.
2. Выполнить пункты 3-10 из **Задания №5**. Для ввода карточки использовать информацию из пункта 2 **Задания №5**.
При этом необходимо не забыть, что согласно пункту 4 из **Задания №5**, программа **может завершиться**! 
3. После вывода на экран карточки пациента (существующей или же только введенной) пользователь должен видеть в терминале следующую информацию и приглашение к вводу (количество черточек должно равняться **50**):
```
--------------------------------------------------
Введите:
 - 1, если хотите посмотреть список дат предыдущих посещений;
 - 2, если хотите посмотреть запись предыдущего посещения;
 - 3, если хотите начать запись в текущем посещении;
 - 4, если хотите закончить прием и завершить программу.
--------------------------------------------------
```
4. Пользователь может выбирать любые опции до бесконечности, пока не будет выбрана опция 4!
5. При вводе опции 1 необходимо:
   
   **ЕСЛИ** в папке *visits* в папке пациента есть хоть один файл, то выводить имена этих файлов в таком виде (без расширения!): 
   - ```
     Предыдущие приемы:
     2024-09-03
     2024-09-06
     2024-09-10

   **ИНАЧЕ**:
   - `Это первый прием!`.
6. При вводе опции 2 необходимо:

    **ЕСЛИ** в папке *visits* в папке пациента есть хоть один файл, то запрашивать файл с приемом, который необходимо посмотреть: 
   - `Введите дату приема, который хотите посмотреть: `
   
        **ЕСЛИ** такой прием есть, то вывести содержимое на экран без обработки;
     
        **ИНАЧЕ** выводить фразу - `Такого приема не было!`.

   **ИНАЧЕ**:
   - `Это первый прием!`.
7. При вводе опции 3 необходимо выполнить пункты 5-9 из **Задания 3**.
8. При вводе опции 4 необходимо:
   - прочитать файл *schedule.csv*;
   - в строке c ФИО принимаемого пациента в колонке `Принят(-а) врачом` заменить значение `Нет` на `Да`.
   - записать обновленную очередь в тот же файл *schedule.csv* в том же виде, как и до этого, просто с одним измененным значением.
   - **завершить программу**!!!

### Задание 9

Проверь, что все файлы *task* присутствуют в папке *src* и что работают программы из файлов *task_6.py* и *task_8.py*.
